{
  "address": "0x324568eB61369C037B67c0d994cdb2D1ebBabea2",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256[8]",
          "name": "",
          "type": "uint256[8]"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Pairing.G1Point",
              "name": "alpha1",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256[2]",
                  "name": "x",
                  "type": "uint256[2]"
                },
                {
                  "internalType": "uint256[2]",
                  "name": "y",
                  "type": "uint256[2]"
                }
              ],
              "internalType": "struct Pairing.G2Point",
              "name": "beta2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256[2]",
                  "name": "x",
                  "type": "uint256[2]"
                },
                {
                  "internalType": "uint256[2]",
                  "name": "y",
                  "type": "uint256[2]"
                }
              ],
              "internalType": "struct Pairing.G2Point",
              "name": "gamma2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256[2]",
                  "name": "x",
                  "type": "uint256[2]"
                },
                {
                  "internalType": "uint256[2]",
                  "name": "y",
                  "type": "uint256[2]"
                }
              ],
              "internalType": "struct Pairing.G2Point",
              "name": "delta2",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "x",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "y",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Pairing.G1Point[]",
              "name": "ic",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct SnarkCommon.VerifyingKey",
          "name": "",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "result",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x3255fbb9494236df59c2ccf23ec4a7322b1ff393a3325a9907eedf2b970fc4d5",
  "receipt": {
    "to": null,
    "from": "0x2a1F5eB3e84e58e6F1e565306298B9dE1273f203",
    "contractAddress": "0x324568eB61369C037B67c0d994cdb2D1ebBabea2",
    "transactionIndex": 0,
    "gasUsed": "311912",
    "logsBloom": "0x00200000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000040000000000000000000000000200000000000000000000000000000000000000000000",
    "blockHash": "0x9ee3c9c70d55f4312b36cc26f355ef2095b7304f3468a6bd791838ac5657f1b2",
    "transactionHash": "0x3255fbb9494236df59c2ccf23ec4a7322b1ff393a3325a9907eedf2b970fc4d5",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 12364700,
        "transactionHash": "0x3255fbb9494236df59c2ccf23ec4a7322b1ff393a3325a9907eedf2b970fc4d5",
        "address": "0x0000000000000000000000000000000000007005",
        "topics": [
          "0x33c981baba081f8fd2c52ac6ad1ea95b6814b4376640f55689051f6584729688",
          "0x0000000000000000000000002a1f5eb3e84e58e6f1e565306298b9de1273f203"
        ],
        "data": "0x000000000000000000000000324568eb61369c037b67c0d994cdb2d1ebbabea2",
        "logIndex": 0,
        "blockHash": "0x9ee3c9c70d55f4312b36cc26f355ef2095b7304f3468a6bd791838ac5657f1b2"
      }
    ],
    "blockNumber": 12364700,
    "cumulativeGasUsed": "311912",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "43b0cf0d58ff20ad1ac37b71c168ebf9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"\",\"type\":\"uint256[8]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct Pairing.G1Point\",\"name\":\"alpha1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"x\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"y\",\"type\":\"uint256[2]\"}],\"internalType\":\"struct Pairing.G2Point\",\"name\":\"beta2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"x\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"y\",\"type\":\"uint256[2]\"}],\"internalType\":\"struct Pairing.G2Point\",\"name\":\"gamma2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256[2]\",\"name\":\"x\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"y\",\"type\":\"uint256[2]\"}],\"internalType\":\"struct Pairing.G2Point\",\"name\":\"delta2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct Pairing.G1Point[]\",\"name\":\"ic\",\"type\":\"tuple[]\"}],\"internalType\":\"struct SnarkCommon.VerifyingKey\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"verify(uint256[8],((uint256,uint256),(uint256[2],uint256[2]),(uint256[2],uint256[2]),(uint256[2],uint256[2]),(uint256,uint256)[]),uint256)\":{\"returns\":{\"result\":\"Whether the proof is valid given the verifying key and public\"}}},\"title\":\"MockVerifier\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"verify(uint256[8],((uint256,uint256),(uint256[2],uint256[2]),(uint256[2],uint256[2]),(uint256[2],uint256[2]),(uint256,uint256)[]),uint256)\":{\"notice\":\"Verify a zk-SNARK proof (test only return always true)\"}},\"notice\":\"a MockVerifier to be used for testing\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MockVerifier.sol\":\"SnarkVerifier\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/MockVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport { SnarkConstants } from \\\"./crypto/SnarkConstants.sol\\\";\\nimport { SnarkCommon } from \\\"./crypto/SnarkCommon.sol\\\";\\nimport { IVerifier } from \\\"./interfaces/IVerifier.sol\\\";\\n\\n/// @title MockVerifier\\n/// @notice a MockVerifier to be used for testing\\ncontract SnarkVerifier is IVerifier, SnarkConstants, SnarkCommon {\\n  /// @notice Verify a zk-SNARK proof (test only return always true)\\n  /// @return result Whether the proof is valid given the verifying key and public\\n  function verify(uint256[8] memory, VerifyingKey memory, uint256) public pure override returns (bool result) {\\n    result = true;\\n  }\\n}\\n\",\"keccak256\":\"0xbeff66c6ef6e0991d676b18af61d3d1bead4a86df14a02131157e70a634449c2\",\"license\":\"MIT\"},\"contracts/crypto/Pairing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Copyright 2017 Christian Reitwiessner\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\n// of this software and associated documentation files (the \\\"Software\\\"), to\\n// deal in the Software without restriction, including without limitation the\\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\\n// sell copies of the Software, and to permit persons to whom the Software is\\n// furnished to do so, subject to the following conditions:\\n// The above copyright notice and this permission notice shall be included in\\n// all copies or substantial portions of the Software.\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\\n// IN THE SOFTWARE.\\n\\n// 2019 OKIMS\\n\\npragma solidity ^0.8.10;\\n\\n/// @title Pairing\\n/// @notice A library implementing the alt_bn128 elliptic curve operations.\\nlibrary Pairing {\\n  uint256 public constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n\\n  struct G1Point {\\n    uint256 x;\\n    uint256 y;\\n  }\\n\\n  // Encoding of field elements is: X[0] * z + X[1]\\n  struct G2Point {\\n    uint256[2] x;\\n    uint256[2] y;\\n  }\\n\\n  /// @notice custom errors\\n  error PairingAddFailed();\\n  error PairingMulFailed();\\n  error PairingOpcodeFailed();\\n\\n  /// @notice The negation of p, i.e. p.plus(p.negate()) should be zero.\\n  function negate(G1Point memory p) internal pure returns (G1Point memory) {\\n    // The prime q in the base field F_q for G1\\n    if (p.x == 0 && p.y == 0) {\\n      return G1Point(0, 0);\\n    } else {\\n      return G1Point(p.x, PRIME_Q - (p.y % PRIME_Q));\\n    }\\n  }\\n\\n  /// @notice r Returns the sum of two points of G1.\\n  function plus(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\\n    uint256[4] memory input;\\n    input[0] = p1.x;\\n    input[1] = p1.y;\\n    input[2] = p2.x;\\n    input[3] = p2.y;\\n    bool success;\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\\n      // Use \\\"invalid\\\" to make gas estimation work\\n      switch success\\n      case 0 {\\n        invalid()\\n      }\\n    }\\n\\n    if (!success) {\\n      revert PairingAddFailed();\\n    }\\n  }\\n\\n  /// @notice r Return the product of a point on G1 and a scalar, i.e.\\n  ///         p == p.scalarMul(1) and p.plus(p) == p.scalarMul(2) for all\\n  ///         points p.\\n  function scalarMul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\\n    uint256[3] memory input;\\n    input[0] = p.x;\\n    input[1] = p.y;\\n    input[2] = s;\\n    bool success;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\\n      // Use \\\"invalid\\\" to make gas estimation work\\n      switch success\\n      case 0 {\\n        invalid()\\n      }\\n    }\\n\\n    if (!success) {\\n      revert PairingMulFailed();\\n    }\\n  }\\n\\n  /// @return isValid The result of computing the pairing check\\n  ///         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\\n  ///        For example,\\n  ///        pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\\n  function pairing(\\n    G1Point memory a1,\\n    G2Point memory a2,\\n    G1Point memory b1,\\n    G2Point memory b2,\\n    G1Point memory c1,\\n    G2Point memory c2,\\n    G1Point memory d1,\\n    G2Point memory d2\\n  ) internal view returns (bool isValid) {\\n    G1Point[4] memory p1 = [a1, b1, c1, d1];\\n    G2Point[4] memory p2 = [a2, b2, c2, d2];\\n\\n    uint256 inputSize = 24;\\n    uint256[] memory input = new uint256[](inputSize);\\n\\n    for (uint256 i = 0; i < 4; i++) {\\n      uint256 j = i * 6;\\n      input[j + 0] = p1[i].x;\\n      input[j + 1] = p1[i].y;\\n      input[j + 2] = p2[i].x[0];\\n      input[j + 3] = p2[i].x[1];\\n      input[j + 4] = p2[i].y[0];\\n      input[j + 5] = p2[i].y[1];\\n    }\\n\\n    uint256[1] memory out;\\n    bool success;\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\\n      // Use \\\"invalid\\\" to make gas estimation work\\n      switch success\\n      case 0 {\\n        invalid()\\n      }\\n    }\\n\\n    if (!success) {\\n      revert PairingOpcodeFailed();\\n    }\\n\\n    isValid = out[0] != 0;\\n  }\\n}\\n\",\"keccak256\":\"0x5ce2f85d56cec9a08960ebf54fe89a0867deb7f97d3151699ba238848598a1a4\",\"license\":\"MIT\"},\"contracts/crypto/SnarkCommon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\nimport { Pairing } from \\\"./Pairing.sol\\\";\\n\\n/// @title SnarkCommon\\n/// @notice a Contract which holds a struct\\n/// representing a Groth16 verifying key\\ncontract SnarkCommon {\\n  /// @notice a struct representing a Groth16 verifying key\\n  struct VerifyingKey {\\n    Pairing.G1Point alpha1;\\n    Pairing.G2Point beta2;\\n    Pairing.G2Point gamma2;\\n    Pairing.G2Point delta2;\\n    Pairing.G1Point[] ic;\\n  }\\n}\\n\",\"keccak256\":\"0xdccb710f060330d75763c92bd6828dd2cc891c3ea5a30ce30ae221c177a7eba7\",\"license\":\"MIT\"},\"contracts/crypto/SnarkConstants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n/// @title SnarkConstants\\n/// @notice This contract contains constants related to the SNARK\\n/// components of MACI.\\ncontract SnarkConstants {\\n  /// @notice The scalar field\\n  uint256 internal constant SNARK_SCALAR_FIELD =\\n    21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n  /// @notice The public key here is the first Pedersen base\\n  /// point from iden3's circomlib implementation of the Pedersen hash.\\n  /// Since it is generated using a hash-to-curve function, we are\\n  /// confident that no-one knows the private key associated with this\\n  /// public key. See:\\n  /// https://github.com/iden3/circomlib/blob/d5ed1c3ce4ca137a6b3ca48bec4ac12c1b38957a/src/pedersen_printbases.js\\n  /// Its hash should equal\\n  /// 6769006970205099520508948723718471724660867171122235270773600567925038008762.\\n  uint256 internal constant PAD_PUBKEY_X =\\n    10457101036533406547632367118273992217979173478358440826365724437999023779287;\\n  uint256 internal constant PAD_PUBKEY_Y =\\n    19824078218392094440610104313265183977899662750282163392862422243483260492317;\\n\\n  /// @notice The Keccack256 hash of 'Maci'\\n  uint256 internal constant NOTHING_UP_MY_SLEEVE =\\n    8370432830353022751713833565135785980866757267633941821328460903436894336785;\\n}\\n\",\"keccak256\":\"0xea489c5ac94d4f25f6255dbfeed0388c2841ead6d9d5e52a19bc8dd2c27b4d21\",\"license\":\"MIT\"},\"contracts/interfaces/IVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport { SnarkCommon } from \\\"../crypto/SnarkCommon.sol\\\";\\n\\n/// @title IVerifier\\n/// @notice an interface for a Groth16 verifier contract\\ninterface IVerifier {\\n  /// @notice Verify a zk-SNARK proof\\n  /// @param _proof The proof\\n  /// @param vk The verifying key\\n  /// @param input The public inputs to the circuit\\n  /// @return Whether the proof is valid given the verifying key and public\\n  ///          input. Note that this function only supports one public input.\\n  ///          Refer to the Semaphore source code for a verifier that supports\\n  ///          multiple public inputs.\\n  function verify(\\n    uint256[8] memory _proof,\\n    SnarkCommon.VerifyingKey memory vk,\\n    uint256 input\\n  ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xf237bf3e3dbc948b577cb689eeecf3633c38205e6bd8e8ef0eb1356197e02247\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506103c2806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806322b72c9414610030575b600080fd5b61004761003e36600461022f565b50600192915050565b604051901515815260200160405180910390f35b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156100945761009461005b565b60405290565b60405160a0810167ffffffffffffffff811182821017156100945761009461005b565b604051601f8201601f1916810167ffffffffffffffff811182821017156100e6576100e661005b565b604052919050565b600060405161010080820182811067ffffffffffffffff821117156101155761011561005b565b604052909150819083018481111561012c57600080fd5b835b8181101561014657803583526020928301920161012e565b50505092915050565b60006040828403121561016157600080fd5b610169610071565b9050813581526020820135602082015292915050565b600082601f83011261019057600080fd5b6040516040810181811067ffffffffffffffff821117156101b3576101b361005b565b80604052508060408401858111156101ca57600080fd5b845b818110156101e45780358352602092830192016101cc565b509195945050505050565b60006080828403121561020157600080fd5b610209610071565b9050610215838361017f565b8152610224836040840161017f565b602082015292915050565b600080600061014080858703121561024657600080fd5b85601f86011261025557600080fd5b61025f86866100ee565b935061010085013567ffffffffffffffff8082111561027d57600080fd5b908601906101e0828903121561029257600080fd5b61029a61009a565b6102a4898461014f565b815260406102b48a8286016101ef565b602081818501526102c88c60c088016101ef565b838501526102d88c8888016101ef565b60608501526101c08601359650848711156102f257600080fd5b86860196508b601f88011261030657600080fd5b863595508486111561031a5761031a61005b565b610328818760051b016100bd565b86815260069690961b8701810195818101955091508b86111561034a57600080fd5b958601955b85871015610370576103618c8861014f565b8552958201959384019361034f565b506080830152509598959750505050610120939093013592505056fea26469706673582212200df9264fd7f93a03cbfd70271cdae93fdee0132f67fc1d4ad1f3aaffb5f6b5ab64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c806322b72c9414610030575b600080fd5b61004761003e36600461022f565b50600192915050565b604051901515815260200160405180910390f35b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156100945761009461005b565b60405290565b60405160a0810167ffffffffffffffff811182821017156100945761009461005b565b604051601f8201601f1916810167ffffffffffffffff811182821017156100e6576100e661005b565b604052919050565b600060405161010080820182811067ffffffffffffffff821117156101155761011561005b565b604052909150819083018481111561012c57600080fd5b835b8181101561014657803583526020928301920161012e565b50505092915050565b60006040828403121561016157600080fd5b610169610071565b9050813581526020820135602082015292915050565b600082601f83011261019057600080fd5b6040516040810181811067ffffffffffffffff821117156101b3576101b361005b565b80604052508060408401858111156101ca57600080fd5b845b818110156101e45780358352602092830192016101cc565b509195945050505050565b60006080828403121561020157600080fd5b610209610071565b9050610215838361017f565b8152610224836040840161017f565b602082015292915050565b600080600061014080858703121561024657600080fd5b85601f86011261025557600080fd5b61025f86866100ee565b935061010085013567ffffffffffffffff8082111561027d57600080fd5b908601906101e0828903121561029257600080fd5b61029a61009a565b6102a4898461014f565b815260406102b48a8286016101ef565b602081818501526102c88c60c088016101ef565b838501526102d88c8888016101ef565b60608501526101c08601359650848711156102f257600080fd5b86860196508b601f88011261030657600080fd5b863595508486111561031a5761031a61005b565b610328818760051b016100bd565b86815260069690961b8701810195818101955091508b86111561034a57600080fd5b958601955b85871015610370576103618c8861014f565b8552958201959384019361034f565b506080830152509598959750505050610120939093013592505056fea26469706673582212200df9264fd7f93a03cbfd70271cdae93fdee0132f67fc1d4ad1f3aaffb5f6b5ab64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "verify(uint256[8],((uint256,uint256),(uint256[2],uint256[2]),(uint256[2],uint256[2]),(uint256[2],uint256[2]),(uint256,uint256)[]),uint256)": {
        "returns": {
          "result": "Whether the proof is valid given the verifying key and public"
        }
      }
    },
    "title": "MockVerifier",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "verify(uint256[8],((uint256,uint256),(uint256[2],uint256[2]),(uint256[2],uint256[2]),(uint256[2],uint256[2]),(uint256,uint256)[]),uint256)": {
        "notice": "Verify a zk-SNARK proof (test only return always true)"
      }
    },
    "notice": "a MockVerifier to be used for testing",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}